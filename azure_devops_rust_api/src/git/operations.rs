// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
#![doc = "generated by AutoRust"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
#![allow(clippy::redundant_clone)]
use super::models;
#[derive(Clone)]
pub struct Client {
    endpoint: String,
    credential: crate::auth::Credential,
    scopes: Vec<String>,
    pipeline: azure_core::Pipeline,
}
#[derive(Clone)]
pub struct ClientBuilder {
    credential: crate::auth::Credential,
    endpoint: Option<String>,
    scopes: Option<Vec<String>>,
}
pub const DEFAULT_ENDPOINT: &str = "https://dev.azure.com";
impl ClientBuilder {
    pub fn new(credential: crate::auth::Credential) -> Self {
        Self {
            credential,
            endpoint: None,
            scopes: None,
        }
    }
    pub fn endpoint(mut self, endpoint: impl Into<String>) -> Self {
        self.endpoint = Some(endpoint.into());
        self
    }
    pub fn scopes(mut self, scopes: &[&str]) -> Self {
        self.scopes = Some(scopes.iter().map(|scope| (*scope).to_owned()).collect());
        self
    }
    pub fn build(self) -> Client {
        let endpoint = self.endpoint.unwrap_or_else(|| DEFAULT_ENDPOINT.to_owned());
        let scopes = self
            .scopes
            .unwrap_or_else(|| vec![format!("{}/", endpoint)]);
        Client::new(endpoint, self.credential, scopes)
    }
}
impl Client {
    pub(crate) fn endpoint(&self) -> &str {
        self.endpoint.as_str()
    }
    pub(crate) fn credential(&self) -> &crate::auth::Credential {
        &self.credential
    }
    pub(crate) async fn send(
        &self,
        request: impl Into<azure_core::Request>,
    ) -> azure_core::error::Result<azure_core::Response> {
        let mut context = azure_core::Context::default();
        let mut request = request.into();
        self.pipeline.send(&mut context, &mut request).await
    }
    pub fn new(
        endpoint: impl Into<String>,
        credential: crate::auth::Credential,
        scopes: Vec<String>,
    ) -> Self {
        let endpoint = endpoint.into();
        let pipeline = azure_core::Pipeline::new(
            option_env!("CARGO_PKG_NAME"),
            option_env!("CARGO_PKG_VERSION"),
            azure_core::ClientOptions::default(),
            Vec::new(),
            Vec::new(),
        );
        Self {
            endpoint,
            credential,
            scopes,
            pipeline,
        }
    }
    pub fn annotated_tags(&self) -> annotated_tags::Client {
        annotated_tags::Client(self.clone())
    }
    pub fn blobs(&self) -> blobs::Client {
        blobs::Client(self.clone())
    }
    pub fn cherry_picks(&self) -> cherry_picks::Client {
        cherry_picks::Client(self.clone())
    }
    pub fn commits(&self) -> commits::Client {
        commits::Client(self.clone())
    }
    pub fn diffs(&self) -> diffs::Client {
        diffs::Client(self.clone())
    }
    pub fn forks(&self) -> forks::Client {
        forks::Client(self.clone())
    }
    pub fn import_requests(&self) -> import_requests::Client {
        import_requests::Client(self.clone())
    }
    pub fn items(&self) -> items::Client {
        items::Client(self.clone())
    }
    pub fn merge_bases(&self) -> merge_bases::Client {
        merge_bases::Client(self.clone())
    }
    pub fn merges(&self) -> merges::Client {
        merges::Client(self.clone())
    }
    pub fn policy_configurations(&self) -> policy_configurations::Client {
        policy_configurations::Client(self.clone())
    }
    pub fn pull_request_attachments(&self) -> pull_request_attachments::Client {
        pull_request_attachments::Client(self.clone())
    }
    pub fn pull_request_comment_likes(&self) -> pull_request_comment_likes::Client {
        pull_request_comment_likes::Client(self.clone())
    }
    pub fn pull_request_commits(&self) -> pull_request_commits::Client {
        pull_request_commits::Client(self.clone())
    }
    pub fn pull_request_iteration_changes(&self) -> pull_request_iteration_changes::Client {
        pull_request_iteration_changes::Client(self.clone())
    }
    pub fn pull_request_iteration_statuses(&self) -> pull_request_iteration_statuses::Client {
        pull_request_iteration_statuses::Client(self.clone())
    }
    pub fn pull_request_iterations(&self) -> pull_request_iterations::Client {
        pull_request_iterations::Client(self.clone())
    }
    pub fn pull_request_labels(&self) -> pull_request_labels::Client {
        pull_request_labels::Client(self.clone())
    }
    pub fn pull_request_properties(&self) -> pull_request_properties::Client {
        pull_request_properties::Client(self.clone())
    }
    pub fn pull_request_query(&self) -> pull_request_query::Client {
        pull_request_query::Client(self.clone())
    }
    pub fn pull_request_reviewers(&self) -> pull_request_reviewers::Client {
        pull_request_reviewers::Client(self.clone())
    }
    pub fn pull_request_share(&self) -> pull_request_share::Client {
        pull_request_share::Client(self.clone())
    }
    pub fn pull_request_statuses(&self) -> pull_request_statuses::Client {
        pull_request_statuses::Client(self.clone())
    }
    pub fn pull_request_thread_comments(&self) -> pull_request_thread_comments::Client {
        pull_request_thread_comments::Client(self.clone())
    }
    pub fn pull_request_threads(&self) -> pull_request_threads::Client {
        pull_request_threads::Client(self.clone())
    }
    pub fn pull_request_work_items(&self) -> pull_request_work_items::Client {
        pull_request_work_items::Client(self.clone())
    }
    pub fn pull_requests(&self) -> pull_requests::Client {
        pull_requests::Client(self.clone())
    }
    pub fn pushes(&self) -> pushes::Client {
        pushes::Client(self.clone())
    }
    pub fn refs(&self) -> refs::Client {
        refs::Client(self.clone())
    }
    pub fn refs_favorites(&self) -> refs_favorites::Client {
        refs_favorites::Client(self.clone())
    }
    pub fn repositories(&self) -> repositories::Client {
        repositories::Client(self.clone())
    }
    pub fn reverts(&self) -> reverts::Client {
        reverts::Client(self.clone())
    }
    pub fn stats(&self) -> stats::Client {
        stats::Client(self.clone())
    }
    pub fn statuses(&self) -> statuses::Client {
        statuses::Client(self.clone())
    }
    pub fn suggestions(&self) -> suggestions::Client {
        suggestions::Client(self.clone())
    }
    pub fn trees(&self) -> trees::Client {
        trees::Client(self.clone())
    }
}
pub mod repositories {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_repository_with_parent(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            include_parent: bool,
            project: impl Into<String>,
        ) -> get_repository_with_parent::Builder {
            get_repository_with_parent::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                include_parent,
                project: project.into(),
            }
        }
        pub fn get_deleted_repositories(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
        ) -> get_deleted_repositories::Builder {
            get_deleted_repositories::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
            }
        }
        pub fn get_recycle_bin_repositories(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
        ) -> get_recycle_bin_repositories::Builder {
            get_recycle_bin_repositories::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
            }
        }
        pub fn restore_repository_from_recycle_bin(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitRecycleBinRepositoryDetails>,
            project: impl Into<String>,
            repository_id: impl Into<String>,
        ) -> restore_repository_from_recycle_bin::Builder {
            restore_repository_from_recycle_bin::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                repository_id: repository_id.into(),
            }
        }
        pub fn delete_repository_from_recycle_bin(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            repository_id: impl Into<String>,
        ) -> delete_repository_from_recycle_bin::Builder {
            delete_repository_from_recycle_bin::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                repository_id: repository_id.into(),
            }
        }
        pub fn list(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                include_links: None,
                include_all_urls: None,
                include_hidden: None,
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitRepositoryCreateOptions>,
            project: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                source_ref: None,
            }
        }
        pub fn get_repository(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_repository::Builder {
            get_repository::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                project: project.into(),
            }
        }
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitRepository>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                project: project.into(),
            }
        }
        pub fn delete(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                project: project.into(),
            }
        }
    }
    pub mod get_repository_with_parent {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitRepository;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) include_parent: bool,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}?includeParent={}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.include_parent
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let include_parent = &this.include_parent;
                        url.query_pairs_mut()
                            .append_pair("includeParent", &include_parent.to_string());
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitRepository =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_deleted_repositories {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitDeletedRepositoryList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/deletedrepositories",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitDeletedRepositoryList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_recycle_bin_repositories {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitDeletedRepositoryList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/recycleBin/repositories",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitDeletedRepositoryList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod restore_repository_from_recycle_bin {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitRepository;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitRecycleBinRepositoryDetails,
            pub(crate) project: String,
            pub(crate) repository_id: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/recycleBin/repositories/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitRepository =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod delete_repository_from_recycle_bin {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) repository_id: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/recycleBin/repositories/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::DELETE);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitRepositoryList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) include_links: Option<bool>,
            pub(crate) include_all_urls: Option<bool>,
            pub(crate) include_hidden: Option<bool>,
        }
        impl Builder {
            pub fn include_links(mut self, include_links: bool) -> Self {
                self.include_links = Some(include_links);
                self
            }
            pub fn include_all_urls(mut self, include_all_urls: bool) -> Self {
                self.include_all_urls = Some(include_all_urls);
                self
            }
            pub fn include_hidden(mut self, include_hidden: bool) -> Self {
                self.include_hidden = Some(include_hidden);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(include_links) = &this.include_links {
                            url.query_pairs_mut()
                                .append_pair("includeLinks", &include_links.to_string());
                        }
                        if let Some(include_all_urls) = &this.include_all_urls {
                            url.query_pairs_mut()
                                .append_pair("includeAllUrls", &include_all_urls.to_string());
                        }
                        if let Some(include_hidden) = &this.include_hidden {
                            url.query_pairs_mut()
                                .append_pair("includeHidden", &include_hidden.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitRepositoryList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitRepository;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitRepositoryCreateOptions,
            pub(crate) project: String,
            pub(crate) source_ref: Option<String>,
        }
        impl Builder {
            pub fn source_ref(mut self, source_ref: impl Into<String>) -> Self {
                self.source_ref = Some(source_ref.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        if let Some(source_ref) = &this.source_ref {
                            url.query_pairs_mut().append_pair("sourceRef", source_ref);
                        }
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::CREATED => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitRepository =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_repository {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitRepository;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitRepository =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitRepository;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitRepository,
            pub(crate) repository_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitRepository =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::DELETE);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod commits {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_commits(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_commits::Builder {
            get_commits::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                project: project.into(),
                search_criteria_skip: None,
                search_criteria_top: None,
                search_criteria_author: None,
                search_criteria_compare_version_version: None,
                search_criteria_compare_version_version_options: None,
                search_criteria_compare_version_version_type: None,
                search_criteria_exclude_deletes: None,
                search_criteria_from_commit_id: None,
                search_criteria_from_date: None,
                search_criteria_history_mode: None,
                search_criteria_ids: Vec::new(),
                search_criteria_include_links: None,
                search_criteria_include_push_data: None,
                search_criteria_include_user_image_url: None,
                search_criteria_include_work_items: None,
                search_criteria_item_path: None,
                search_criteria_item_version_version: None,
                search_criteria_item_version_version_options: None,
                search_criteria_item_version_version_type: None,
                search_criteria_show_oldest_commits_first: None,
                search_criteria_to_commit_id: None,
                search_criteria_to_date: None,
                search_criteria_user: None,
            }
        }
        pub fn get_push_commits(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            push_id: i32,
            project: impl Into<String>,
        ) -> get_push_commits::Builder {
            get_push_commits::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                push_id,
                project: project.into(),
                top: None,
                skip: None,
                include_links: None,
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            commit_id: impl Into<String>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                commit_id: commit_id.into(),
                repository_id: repository_id.into(),
                project: project.into(),
                change_count: None,
            }
        }
        pub fn get_changes(
            &self,
            organization: impl Into<String>,
            commit_id: impl Into<String>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_changes::Builder {
            get_changes::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                commit_id: commit_id.into(),
                repository_id: repository_id.into(),
                project: project.into(),
                top: None,
                skip: None,
            }
        }
        pub fn get_commits_batch(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitQueryCommitsCriteria>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_commits_batch::Builder {
            get_commits_batch::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                project: project.into(),
                skip: None,
                top: None,
                include_statuses: None,
            }
        }
    }
    pub mod get_commits {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitCommitRefList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) project: String,
            pub(crate) search_criteria_skip: Option<i32>,
            pub(crate) search_criteria_top: Option<i32>,
            pub(crate) search_criteria_author: Option<String>,
            pub(crate) search_criteria_compare_version_version: Option<String>,
            pub(crate) search_criteria_compare_version_version_options: Option<String>,
            pub(crate) search_criteria_compare_version_version_type: Option<String>,
            pub(crate) search_criteria_exclude_deletes: Option<bool>,
            pub(crate) search_criteria_from_commit_id: Option<String>,
            pub(crate) search_criteria_from_date: Option<String>,
            pub(crate) search_criteria_history_mode: Option<String>,
            pub(crate) search_criteria_ids: Vec<String>,
            pub(crate) search_criteria_include_links: Option<bool>,
            pub(crate) search_criteria_include_push_data: Option<bool>,
            pub(crate) search_criteria_include_user_image_url: Option<bool>,
            pub(crate) search_criteria_include_work_items: Option<bool>,
            pub(crate) search_criteria_item_path: Option<String>,
            pub(crate) search_criteria_item_version_version: Option<String>,
            pub(crate) search_criteria_item_version_version_options: Option<String>,
            pub(crate) search_criteria_item_version_version_type: Option<String>,
            pub(crate) search_criteria_show_oldest_commits_first: Option<bool>,
            pub(crate) search_criteria_to_commit_id: Option<String>,
            pub(crate) search_criteria_to_date: Option<String>,
            pub(crate) search_criteria_user: Option<String>,
        }
        impl Builder {
            pub fn search_criteria_skip(mut self, search_criteria_skip: i32) -> Self {
                self.search_criteria_skip = Some(search_criteria_skip);
                self
            }
            pub fn search_criteria_top(mut self, search_criteria_top: i32) -> Self {
                self.search_criteria_top = Some(search_criteria_top);
                self
            }
            pub fn search_criteria_author(
                mut self,
                search_criteria_author: impl Into<String>,
            ) -> Self {
                self.search_criteria_author = Some(search_criteria_author.into());
                self
            }
            pub fn search_criteria_compare_version_version(
                mut self,
                search_criteria_compare_version_version: impl Into<String>,
            ) -> Self {
                self.search_criteria_compare_version_version =
                    Some(search_criteria_compare_version_version.into());
                self
            }
            pub fn search_criteria_compare_version_version_options(
                mut self,
                search_criteria_compare_version_version_options: impl Into<String>,
            ) -> Self {
                self.search_criteria_compare_version_version_options =
                    Some(search_criteria_compare_version_version_options.into());
                self
            }
            pub fn search_criteria_compare_version_version_type(
                mut self,
                search_criteria_compare_version_version_type: impl Into<String>,
            ) -> Self {
                self.search_criteria_compare_version_version_type =
                    Some(search_criteria_compare_version_version_type.into());
                self
            }
            pub fn search_criteria_exclude_deletes(
                mut self,
                search_criteria_exclude_deletes: bool,
            ) -> Self {
                self.search_criteria_exclude_deletes = Some(search_criteria_exclude_deletes);
                self
            }
            pub fn search_criteria_from_commit_id(
                mut self,
                search_criteria_from_commit_id: impl Into<String>,
            ) -> Self {
                self.search_criteria_from_commit_id = Some(search_criteria_from_commit_id.into());
                self
            }
            pub fn search_criteria_from_date(
                mut self,
                search_criteria_from_date: impl Into<String>,
            ) -> Self {
                self.search_criteria_from_date = Some(search_criteria_from_date.into());
                self
            }
            pub fn search_criteria_history_mode(
                mut self,
                search_criteria_history_mode: impl Into<String>,
            ) -> Self {
                self.search_criteria_history_mode = Some(search_criteria_history_mode.into());
                self
            }
            pub fn search_criteria_ids(mut self, search_criteria_ids: Vec<String>) -> Self {
                self.search_criteria_ids = search_criteria_ids;
                self
            }
            pub fn search_criteria_include_links(
                mut self,
                search_criteria_include_links: bool,
            ) -> Self {
                self.search_criteria_include_links = Some(search_criteria_include_links);
                self
            }
            pub fn search_criteria_include_push_data(
                mut self,
                search_criteria_include_push_data: bool,
            ) -> Self {
                self.search_criteria_include_push_data = Some(search_criteria_include_push_data);
                self
            }
            pub fn search_criteria_include_user_image_url(
                mut self,
                search_criteria_include_user_image_url: bool,
            ) -> Self {
                self.search_criteria_include_user_image_url =
                    Some(search_criteria_include_user_image_url);
                self
            }
            pub fn search_criteria_include_work_items(
                mut self,
                search_criteria_include_work_items: bool,
            ) -> Self {
                self.search_criteria_include_work_items = Some(search_criteria_include_work_items);
                self
            }
            pub fn search_criteria_item_path(
                mut self,
                search_criteria_item_path: impl Into<String>,
            ) -> Self {
                self.search_criteria_item_path = Some(search_criteria_item_path.into());
                self
            }
            pub fn search_criteria_item_version_version(
                mut self,
                search_criteria_item_version_version: impl Into<String>,
            ) -> Self {
                self.search_criteria_item_version_version =
                    Some(search_criteria_item_version_version.into());
                self
            }
            pub fn search_criteria_item_version_version_options(
                mut self,
                search_criteria_item_version_version_options: impl Into<String>,
            ) -> Self {
                self.search_criteria_item_version_version_options =
                    Some(search_criteria_item_version_version_options.into());
                self
            }
            pub fn search_criteria_item_version_version_type(
                mut self,
                search_criteria_item_version_version_type: impl Into<String>,
            ) -> Self {
                self.search_criteria_item_version_version_type =
                    Some(search_criteria_item_version_version_type.into());
                self
            }
            pub fn search_criteria_show_oldest_commits_first(
                mut self,
                search_criteria_show_oldest_commits_first: bool,
            ) -> Self {
                self.search_criteria_show_oldest_commits_first =
                    Some(search_criteria_show_oldest_commits_first);
                self
            }
            pub fn search_criteria_to_commit_id(
                mut self,
                search_criteria_to_commit_id: impl Into<String>,
            ) -> Self {
                self.search_criteria_to_commit_id = Some(search_criteria_to_commit_id.into());
                self
            }
            pub fn search_criteria_to_date(
                mut self,
                search_criteria_to_date: impl Into<String>,
            ) -> Self {
                self.search_criteria_to_date = Some(search_criteria_to_date.into());
                self
            }
            pub fn search_criteria_user(mut self, search_criteria_user: impl Into<String>) -> Self {
                self.search_criteria_user = Some(search_criteria_user.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/commits?",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(search_criteria_skip) = &this.search_criteria_skip {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.$skip",
                                &search_criteria_skip.to_string(),
                            );
                        }
                        if let Some(search_criteria_top) = &this.search_criteria_top {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.$top",
                                &search_criteria_top.to_string(),
                            );
                        }
                        if let Some(search_criteria_author) = &this.search_criteria_author {
                            url.query_pairs_mut()
                                .append_pair("searchCriteria.author", search_criteria_author);
                        }
                        if let Some(search_criteria_compare_version_version) =
                            &this.search_criteria_compare_version_version
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.compareVersion.version",
                                search_criteria_compare_version_version,
                            );
                        }
                        if let Some(search_criteria_compare_version_version_options) =
                            &this.search_criteria_compare_version_version_options
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.compareVersion.versionOptions",
                                search_criteria_compare_version_version_options,
                            );
                        }
                        if let Some(search_criteria_compare_version_version_type) =
                            &this.search_criteria_compare_version_version_type
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.compareVersion.versionType",
                                search_criteria_compare_version_version_type,
                            );
                        }
                        if let Some(search_criteria_exclude_deletes) =
                            &this.search_criteria_exclude_deletes
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.excludeDeletes",
                                &search_criteria_exclude_deletes.to_string(),
                            );
                        }
                        if let Some(search_criteria_from_commit_id) =
                            &this.search_criteria_from_commit_id
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.fromCommitId",
                                search_criteria_from_commit_id,
                            );
                        }
                        if let Some(search_criteria_from_date) = &this.search_criteria_from_date {
                            url.query_pairs_mut()
                                .append_pair("searchCriteria.fromDate", search_criteria_from_date);
                        }
                        if let Some(search_criteria_history_mode) =
                            &this.search_criteria_history_mode
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.historyMode",
                                search_criteria_history_mode,
                            );
                        }
                        if let Some(search_criteria_include_links) =
                            &this.search_criteria_include_links
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.includeLinks",
                                &search_criteria_include_links.to_string(),
                            );
                        }
                        if let Some(search_criteria_include_push_data) =
                            &this.search_criteria_include_push_data
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.includePushData",
                                &search_criteria_include_push_data.to_string(),
                            );
                        }
                        if let Some(search_criteria_include_user_image_url) =
                            &this.search_criteria_include_user_image_url
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.includeUserImageUrl",
                                &search_criteria_include_user_image_url.to_string(),
                            );
                        }
                        if let Some(search_criteria_include_work_items) =
                            &this.search_criteria_include_work_items
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.includeWorkItems",
                                &search_criteria_include_work_items.to_string(),
                            );
                        }
                        if let Some(search_criteria_item_path) = &this.search_criteria_item_path {
                            url.query_pairs_mut()
                                .append_pair("searchCriteria.itemPath", search_criteria_item_path);
                        }
                        if let Some(search_criteria_item_version_version) =
                            &this.search_criteria_item_version_version
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.itemVersion.version",
                                search_criteria_item_version_version,
                            );
                        }
                        if let Some(search_criteria_item_version_version_options) =
                            &this.search_criteria_item_version_version_options
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.itemVersion.versionOptions",
                                search_criteria_item_version_version_options,
                            );
                        }
                        if let Some(search_criteria_item_version_version_type) =
                            &this.search_criteria_item_version_version_type
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.itemVersion.versionType",
                                search_criteria_item_version_version_type,
                            );
                        }
                        if let Some(search_criteria_show_oldest_commits_first) =
                            &this.search_criteria_show_oldest_commits_first
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.showOldestCommitsFirst",
                                &search_criteria_show_oldest_commits_first.to_string(),
                            );
                        }
                        if let Some(search_criteria_to_commit_id) =
                            &this.search_criteria_to_commit_id
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.toCommitId",
                                search_criteria_to_commit_id,
                            );
                        }
                        if let Some(search_criteria_to_date) = &this.search_criteria_to_date {
                            url.query_pairs_mut()
                                .append_pair("searchCriteria.toDate", search_criteria_to_date);
                        }
                        if let Some(search_criteria_user) = &this.search_criteria_user {
                            url.query_pairs_mut()
                                .append_pair("searchCriteria.user", search_criteria_user);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitCommitRefList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_push_commits {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitCommitRefList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) push_id: i32,
            pub(crate) project: String,
            pub(crate) top: Option<i32>,
            pub(crate) skip: Option<i32>,
            pub(crate) include_links: Option<bool>,
        }
        impl Builder {
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn skip(mut self, skip: i32) -> Self {
                self.skip = Some(skip);
                self
            }
            pub fn include_links(mut self, include_links: bool) -> Self {
                self.include_links = Some(include_links);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/commits",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let push_id = &this.push_id;
                        url.query_pairs_mut()
                            .append_pair("pushId", &push_id.to_string());
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("top", &top.to_string());
                        }
                        if let Some(skip) = &this.skip {
                            url.query_pairs_mut().append_pair("skip", &skip.to_string());
                        }
                        if let Some(include_links) = &this.include_links {
                            url.query_pairs_mut()
                                .append_pair("includeLinks", &include_links.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitCommitRefList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitCommit;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) commit_id: String,
            pub(crate) repository_id: String,
            pub(crate) project: String,
            pub(crate) change_count: Option<i32>,
        }
        impl Builder {
            pub fn change_count(mut self, change_count: i32) -> Self {
                self.change_count = Some(change_count);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/commits/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.commit_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(change_count) = &this.change_count {
                            url.query_pairs_mut()
                                .append_pair("changeCount", &change_count.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitCommit =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_changes {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitCommitChanges;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) commit_id: String,
            pub(crate) repository_id: String,
            pub(crate) project: String,
            pub(crate) top: Option<i32>,
            pub(crate) skip: Option<i32>,
        }
        impl Builder {
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn skip(mut self, skip: i32) -> Self {
                self.skip = Some(skip);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/commits/{}/changes",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.commit_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("top", &top.to_string());
                        }
                        if let Some(skip) = &this.skip {
                            url.query_pairs_mut().append_pair("skip", &skip.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitCommitChanges =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_commits_batch {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitCommitRefList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitQueryCommitsCriteria,
            pub(crate) repository_id: String,
            pub(crate) project: String,
            pub(crate) skip: Option<i32>,
            pub(crate) top: Option<i32>,
            pub(crate) include_statuses: Option<bool>,
        }
        impl Builder {
            pub fn skip(mut self, skip: i32) -> Self {
                self.skip = Some(skip);
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn include_statuses(mut self, include_statuses: bool) -> Self {
                self.include_statuses = Some(include_statuses);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/commitsbatch",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        if let Some(skip) = &this.skip {
                            url.query_pairs_mut()
                                .append_pair("$skip", &skip.to_string());
                        }
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("$top", &top.to_string());
                        }
                        if let Some(include_statuses) = &this.include_statuses {
                            url.query_pairs_mut()
                                .append_pair("includeStatuses", &include_statuses.to_string());
                        }
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitCommitRefList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod items {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            path: impl Into<String>,
            project: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                path: path.into(),
                project: project.into(),
                scope_path: None,
                recursion_level: None,
                include_content_metadata: None,
                latest_processed_change: None,
                download: None,
                format: None,
                version_descriptor_version: None,
                version_descriptor_version_options: None,
                version_descriptor_version_type: None,
                include_content: None,
                resolve_lfs: None,
                sanitize: None,
            }
        }
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                project: project.into(),
                scope_path: None,
                recursion_level: None,
                include_content_metadata: None,
                latest_processed_change: None,
                download: None,
                include_links: None,
                format: None,
                version_descriptor_version: None,
                version_descriptor_version_options: None,
                version_descriptor_version_type: None,
            }
        }
        pub fn get_items_batch(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitItemRequestData>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_items_batch::Builder {
            get_items_batch::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                project: project.into(),
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitItem;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) path: String,
            pub(crate) project: String,
            pub(crate) scope_path: Option<String>,
            pub(crate) recursion_level: Option<String>,
            pub(crate) include_content_metadata: Option<bool>,
            pub(crate) latest_processed_change: Option<bool>,
            pub(crate) download: Option<bool>,
            pub(crate) format: Option<String>,
            pub(crate) version_descriptor_version: Option<String>,
            pub(crate) version_descriptor_version_options: Option<String>,
            pub(crate) version_descriptor_version_type: Option<String>,
            pub(crate) include_content: Option<bool>,
            pub(crate) resolve_lfs: Option<bool>,
            pub(crate) sanitize: Option<bool>,
        }
        impl Builder {
            pub fn scope_path(mut self, scope_path: impl Into<String>) -> Self {
                self.scope_path = Some(scope_path.into());
                self
            }
            pub fn recursion_level(mut self, recursion_level: impl Into<String>) -> Self {
                self.recursion_level = Some(recursion_level.into());
                self
            }
            pub fn include_content_metadata(mut self, include_content_metadata: bool) -> Self {
                self.include_content_metadata = Some(include_content_metadata);
                self
            }
            pub fn latest_processed_change(mut self, latest_processed_change: bool) -> Self {
                self.latest_processed_change = Some(latest_processed_change);
                self
            }
            pub fn download(mut self, download: bool) -> Self {
                self.download = Some(download);
                self
            }
            pub fn format(mut self, format: impl Into<String>) -> Self {
                self.format = Some(format.into());
                self
            }
            pub fn version_descriptor_version(
                mut self,
                version_descriptor_version: impl Into<String>,
            ) -> Self {
                self.version_descriptor_version = Some(version_descriptor_version.into());
                self
            }
            pub fn version_descriptor_version_options(
                mut self,
                version_descriptor_version_options: impl Into<String>,
            ) -> Self {
                self.version_descriptor_version_options =
                    Some(version_descriptor_version_options.into());
                self
            }
            pub fn version_descriptor_version_type(
                mut self,
                version_descriptor_version_type: impl Into<String>,
            ) -> Self {
                self.version_descriptor_version_type = Some(version_descriptor_version_type.into());
                self
            }
            pub fn include_content(mut self, include_content: bool) -> Self {
                self.include_content = Some(include_content);
                self
            }
            pub fn resolve_lfs(mut self, resolve_lfs: bool) -> Self {
                self.resolve_lfs = Some(resolve_lfs);
                self
            }
            pub fn sanitize(mut self, sanitize: bool) -> Self {
                self.sanitize = Some(sanitize);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/items?path={}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.path
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let path = &this.path;
                        url.query_pairs_mut().append_pair("path", path);
                        if let Some(scope_path) = &this.scope_path {
                            url.query_pairs_mut().append_pair("scopePath", scope_path);
                        }
                        if let Some(recursion_level) = &this.recursion_level {
                            url.query_pairs_mut()
                                .append_pair("recursionLevel", recursion_level);
                        }
                        if let Some(include_content_metadata) = &this.include_content_metadata {
                            url.query_pairs_mut().append_pair(
                                "includeContentMetadata",
                                &include_content_metadata.to_string(),
                            );
                        }
                        if let Some(latest_processed_change) = &this.latest_processed_change {
                            url.query_pairs_mut().append_pair(
                                "latestProcessedChange",
                                &latest_processed_change.to_string(),
                            );
                        }
                        if let Some(download) = &this.download {
                            url.query_pairs_mut()
                                .append_pair("download", &download.to_string());
                        }
                        if let Some(format) = &this.format {
                            url.query_pairs_mut().append_pair("$format", format);
                        }
                        if let Some(version_descriptor_version) = &this.version_descriptor_version {
                            url.query_pairs_mut().append_pair(
                                "versionDescriptor.version",
                                version_descriptor_version,
                            );
                        }
                        if let Some(version_descriptor_version_options) =
                            &this.version_descriptor_version_options
                        {
                            url.query_pairs_mut().append_pair(
                                "versionDescriptor.versionOptions",
                                version_descriptor_version_options,
                            );
                        }
                        if let Some(version_descriptor_version_type) =
                            &this.version_descriptor_version_type
                        {
                            url.query_pairs_mut().append_pair(
                                "versionDescriptor.versionType",
                                version_descriptor_version_type,
                            );
                        }
                        if let Some(include_content) = &this.include_content {
                            url.query_pairs_mut()
                                .append_pair("includeContent", &include_content.to_string());
                        }
                        if let Some(resolve_lfs) = &this.resolve_lfs {
                            url.query_pairs_mut()
                                .append_pair("resolveLfs", &resolve_lfs.to_string());
                        }
                        if let Some(sanitize) = &this.sanitize {
                            url.query_pairs_mut()
                                .append_pair("sanitize", &sanitize.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitItem = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitItemList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) project: String,
            pub(crate) scope_path: Option<String>,
            pub(crate) recursion_level: Option<String>,
            pub(crate) include_content_metadata: Option<bool>,
            pub(crate) latest_processed_change: Option<bool>,
            pub(crate) download: Option<bool>,
            pub(crate) include_links: Option<bool>,
            pub(crate) format: Option<String>,
            pub(crate) version_descriptor_version: Option<String>,
            pub(crate) version_descriptor_version_options: Option<String>,
            pub(crate) version_descriptor_version_type: Option<String>,
        }
        impl Builder {
            pub fn scope_path(mut self, scope_path: impl Into<String>) -> Self {
                self.scope_path = Some(scope_path.into());
                self
            }
            pub fn recursion_level(mut self, recursion_level: impl Into<String>) -> Self {
                self.recursion_level = Some(recursion_level.into());
                self
            }
            pub fn include_content_metadata(mut self, include_content_metadata: bool) -> Self {
                self.include_content_metadata = Some(include_content_metadata);
                self
            }
            pub fn latest_processed_change(mut self, latest_processed_change: bool) -> Self {
                self.latest_processed_change = Some(latest_processed_change);
                self
            }
            pub fn download(mut self, download: bool) -> Self {
                self.download = Some(download);
                self
            }
            pub fn include_links(mut self, include_links: bool) -> Self {
                self.include_links = Some(include_links);
                self
            }
            pub fn format(mut self, format: impl Into<String>) -> Self {
                self.format = Some(format.into());
                self
            }
            pub fn version_descriptor_version(
                mut self,
                version_descriptor_version: impl Into<String>,
            ) -> Self {
                self.version_descriptor_version = Some(version_descriptor_version.into());
                self
            }
            pub fn version_descriptor_version_options(
                mut self,
                version_descriptor_version_options: impl Into<String>,
            ) -> Self {
                self.version_descriptor_version_options =
                    Some(version_descriptor_version_options.into());
                self
            }
            pub fn version_descriptor_version_type(
                mut self,
                version_descriptor_version_type: impl Into<String>,
            ) -> Self {
                self.version_descriptor_version_type = Some(version_descriptor_version_type.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/items",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(scope_path) = &this.scope_path {
                            url.query_pairs_mut().append_pair("scopePath", scope_path);
                        }
                        if let Some(recursion_level) = &this.recursion_level {
                            url.query_pairs_mut()
                                .append_pair("recursionLevel", recursion_level);
                        }
                        if let Some(include_content_metadata) = &this.include_content_metadata {
                            url.query_pairs_mut().append_pair(
                                "includeContentMetadata",
                                &include_content_metadata.to_string(),
                            );
                        }
                        if let Some(latest_processed_change) = &this.latest_processed_change {
                            url.query_pairs_mut().append_pair(
                                "latestProcessedChange",
                                &latest_processed_change.to_string(),
                            );
                        }
                        if let Some(download) = &this.download {
                            url.query_pairs_mut()
                                .append_pair("download", &download.to_string());
                        }
                        if let Some(include_links) = &this.include_links {
                            url.query_pairs_mut()
                                .append_pair("includeLinks", &include_links.to_string());
                        }
                        if let Some(format) = &this.format {
                            url.query_pairs_mut().append_pair("$format", format);
                        }
                        if let Some(version_descriptor_version) = &this.version_descriptor_version {
                            url.query_pairs_mut().append_pair(
                                "versionDescriptor.version",
                                version_descriptor_version,
                            );
                        }
                        if let Some(version_descriptor_version_options) =
                            &this.version_descriptor_version_options
                        {
                            url.query_pairs_mut().append_pair(
                                "versionDescriptor.versionOptions",
                                version_descriptor_version_options,
                            );
                        }
                        if let Some(version_descriptor_version_type) =
                            &this.version_descriptor_version_type
                        {
                            url.query_pairs_mut().append_pair(
                                "versionDescriptor.versionType",
                                version_descriptor_version_type,
                            );
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitItemList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_items_batch {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = Vec<String>;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitItemRequestData,
            pub(crate) repository_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/itemsbatch",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: Vec<String> = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod stats {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            name: impl Into<String>,
            project: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                name: name.into(),
                project: project.into(),
                base_version_descriptor_version: None,
                base_version_descriptor_version_options: None,
                base_version_descriptor_version_type: None,
            }
        }
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                project: project.into(),
                base_version_descriptor_version: None,
                base_version_descriptor_version_options: None,
                base_version_descriptor_version_type: None,
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitBranchStats;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) name: String,
            pub(crate) project: String,
            pub(crate) base_version_descriptor_version: Option<String>,
            pub(crate) base_version_descriptor_version_options: Option<String>,
            pub(crate) base_version_descriptor_version_type: Option<String>,
        }
        impl Builder {
            pub fn base_version_descriptor_version(
                mut self,
                base_version_descriptor_version: impl Into<String>,
            ) -> Self {
                self.base_version_descriptor_version = Some(base_version_descriptor_version.into());
                self
            }
            pub fn base_version_descriptor_version_options(
                mut self,
                base_version_descriptor_version_options: impl Into<String>,
            ) -> Self {
                self.base_version_descriptor_version_options =
                    Some(base_version_descriptor_version_options.into());
                self
            }
            pub fn base_version_descriptor_version_type(
                mut self,
                base_version_descriptor_version_type: impl Into<String>,
            ) -> Self {
                self.base_version_descriptor_version_type =
                    Some(base_version_descriptor_version_type.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/stats/branches?name={}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.name
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let name = &this.name;
                        url.query_pairs_mut().append_pair("name", name);
                        if let Some(base_version_descriptor_version) =
                            &this.base_version_descriptor_version
                        {
                            url.query_pairs_mut().append_pair(
                                "baseVersionDescriptor.version",
                                base_version_descriptor_version,
                            );
                        }
                        if let Some(base_version_descriptor_version_options) =
                            &this.base_version_descriptor_version_options
                        {
                            url.query_pairs_mut().append_pair(
                                "baseVersionDescriptor.versionOptions",
                                base_version_descriptor_version_options,
                            );
                        }
                        if let Some(base_version_descriptor_version_type) =
                            &this.base_version_descriptor_version_type
                        {
                            url.query_pairs_mut().append_pair(
                                "baseVersionDescriptor.versionType",
                                base_version_descriptor_version_type,
                            );
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitBranchStats =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitBranchStatsList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) project: String,
            pub(crate) base_version_descriptor_version: Option<String>,
            pub(crate) base_version_descriptor_version_options: Option<String>,
            pub(crate) base_version_descriptor_version_type: Option<String>,
        }
        impl Builder {
            pub fn base_version_descriptor_version(
                mut self,
                base_version_descriptor_version: impl Into<String>,
            ) -> Self {
                self.base_version_descriptor_version = Some(base_version_descriptor_version.into());
                self
            }
            pub fn base_version_descriptor_version_options(
                mut self,
                base_version_descriptor_version_options: impl Into<String>,
            ) -> Self {
                self.base_version_descriptor_version_options =
                    Some(base_version_descriptor_version_options.into());
                self
            }
            pub fn base_version_descriptor_version_type(
                mut self,
                base_version_descriptor_version_type: impl Into<String>,
            ) -> Self {
                self.base_version_descriptor_version_type =
                    Some(base_version_descriptor_version_type.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/stats/branches",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(base_version_descriptor_version) =
                            &this.base_version_descriptor_version
                        {
                            url.query_pairs_mut().append_pair(
                                "baseVersionDescriptor.version",
                                base_version_descriptor_version,
                            );
                        }
                        if let Some(base_version_descriptor_version_options) =
                            &this.base_version_descriptor_version_options
                        {
                            url.query_pairs_mut().append_pair(
                                "baseVersionDescriptor.versionOptions",
                                base_version_descriptor_version_options,
                            );
                        }
                        if let Some(base_version_descriptor_version_type) =
                            &this.base_version_descriptor_version_type
                        {
                            url.query_pairs_mut().append_pair(
                                "baseVersionDescriptor.versionType",
                                base_version_descriptor_version_type,
                            );
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitBranchStatsList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod refs_favorites {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                repository_id: None,
                identity_id: None,
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitRefFavorite>,
            project: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            favorite_id: i32,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                favorite_id,
            }
        }
        pub fn delete(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            favorite_id: i32,
        ) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                favorite_id,
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitRefFavoriteList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) repository_id: Option<String>,
            pub(crate) identity_id: Option<String>,
        }
        impl Builder {
            pub fn repository_id(mut self, repository_id: impl Into<String>) -> Self {
                self.repository_id = Some(repository_id.into());
                self
            }
            pub fn identity_id(mut self, identity_id: impl Into<String>) -> Self {
                self.identity_id = Some(identity_id.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/favorites/refs",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(repository_id) = &this.repository_id {
                            url.query_pairs_mut()
                                .append_pair("repositoryId", repository_id);
                        }
                        if let Some(identity_id) = &this.identity_id {
                            url.query_pairs_mut().append_pair("identityId", identity_id);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitRefFavoriteList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitRefFavorite;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitRefFavorite,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/favorites/refs",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitRefFavorite =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitRefFavorite;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) favorite_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/favorites/refs/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.favorite_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitRefFavorite =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) favorite_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/favorites/refs/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.favorite_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::DELETE);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod policy_configurations {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                repository_id: None,
                ref_name: None,
                policy_type: None,
                top: None,
                continuation_token: None,
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::PolicyConfigurationList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) repository_id: Option<String>,
            pub(crate) ref_name: Option<String>,
            pub(crate) policy_type: Option<String>,
            pub(crate) top: Option<i32>,
            pub(crate) continuation_token: Option<String>,
        }
        impl Builder {
            pub fn repository_id(mut self, repository_id: impl Into<String>) -> Self {
                self.repository_id = Some(repository_id.into());
                self
            }
            pub fn ref_name(mut self, ref_name: impl Into<String>) -> Self {
                self.ref_name = Some(ref_name.into());
                self
            }
            pub fn policy_type(mut self, policy_type: impl Into<String>) -> Self {
                self.policy_type = Some(policy_type.into());
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
                self.continuation_token = Some(continuation_token.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/policy/configurations",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(repository_id) = &this.repository_id {
                            url.query_pairs_mut()
                                .append_pair("repositoryId", repository_id);
                        }
                        if let Some(ref_name) = &this.ref_name {
                            url.query_pairs_mut().append_pair("refName", ref_name);
                        }
                        if let Some(policy_type) = &this.policy_type {
                            url.query_pairs_mut().append_pair("policyType", policy_type);
                        }
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("$top", &top.to_string());
                        }
                        if let Some(continuation_token) = &this.continuation_token {
                            url.query_pairs_mut()
                                .append_pair("continuationToken", continuation_token);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::PolicyConfigurationList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod pull_requests {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_pull_requests_by_project(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
        ) -> get_pull_requests_by_project::Builder {
            get_pull_requests_by_project::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                search_criteria_creator_id: None,
                search_criteria_include_links: None,
                search_criteria_repository_id: None,
                search_criteria_reviewer_id: None,
                search_criteria_source_ref_name: None,
                search_criteria_source_repository_id: None,
                search_criteria_status: None,
                search_criteria_target_ref_name: None,
                max_comment_length: None,
                skip: None,
                top: None,
            }
        }
        pub fn get_pull_request_by_id(
            &self,
            organization: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> get_pull_request_by_id::Builder {
            get_pull_request_by_id::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                pull_request_id,
                project: project.into(),
            }
        }
        pub fn get_pull_requests(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_pull_requests::Builder {
            get_pull_requests::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                project: project.into(),
                search_criteria_creator_id: None,
                search_criteria_include_links: None,
                search_criteria_repository_id: None,
                search_criteria_reviewer_id: None,
                search_criteria_source_ref_name: None,
                search_criteria_source_repository_id: None,
                search_criteria_status: None,
                search_criteria_target_ref_name: None,
                max_comment_length: None,
                skip: None,
                top: None,
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitPullRequest>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                project: project.into(),
                supports_iterations: None,
            }
        }
        pub fn get_pull_request(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> get_pull_request::Builder {
            get_pull_request::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
                max_comment_length: None,
                skip: None,
                top: None,
                include_commits: None,
                include_work_item_refs: None,
            }
        }
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitPullRequest>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
            }
        }
    }
    pub mod get_pull_requests_by_project {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequestList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) search_criteria_creator_id: Option<String>,
            pub(crate) search_criteria_include_links: Option<bool>,
            pub(crate) search_criteria_repository_id: Option<String>,
            pub(crate) search_criteria_reviewer_id: Option<String>,
            pub(crate) search_criteria_source_ref_name: Option<String>,
            pub(crate) search_criteria_source_repository_id: Option<String>,
            pub(crate) search_criteria_status: Option<String>,
            pub(crate) search_criteria_target_ref_name: Option<String>,
            pub(crate) max_comment_length: Option<i32>,
            pub(crate) skip: Option<i32>,
            pub(crate) top: Option<i32>,
        }
        impl Builder {
            pub fn search_criteria_creator_id(
                mut self,
                search_criteria_creator_id: impl Into<String>,
            ) -> Self {
                self.search_criteria_creator_id = Some(search_criteria_creator_id.into());
                self
            }
            pub fn search_criteria_include_links(
                mut self,
                search_criteria_include_links: bool,
            ) -> Self {
                self.search_criteria_include_links = Some(search_criteria_include_links);
                self
            }
            pub fn search_criteria_repository_id(
                mut self,
                search_criteria_repository_id: impl Into<String>,
            ) -> Self {
                self.search_criteria_repository_id = Some(search_criteria_repository_id.into());
                self
            }
            pub fn search_criteria_reviewer_id(
                mut self,
                search_criteria_reviewer_id: impl Into<String>,
            ) -> Self {
                self.search_criteria_reviewer_id = Some(search_criteria_reviewer_id.into());
                self
            }
            pub fn search_criteria_source_ref_name(
                mut self,
                search_criteria_source_ref_name: impl Into<String>,
            ) -> Self {
                self.search_criteria_source_ref_name = Some(search_criteria_source_ref_name.into());
                self
            }
            pub fn search_criteria_source_repository_id(
                mut self,
                search_criteria_source_repository_id: impl Into<String>,
            ) -> Self {
                self.search_criteria_source_repository_id =
                    Some(search_criteria_source_repository_id.into());
                self
            }
            pub fn search_criteria_status(
                mut self,
                search_criteria_status: impl Into<String>,
            ) -> Self {
                self.search_criteria_status = Some(search_criteria_status.into());
                self
            }
            pub fn search_criteria_target_ref_name(
                mut self,
                search_criteria_target_ref_name: impl Into<String>,
            ) -> Self {
                self.search_criteria_target_ref_name = Some(search_criteria_target_ref_name.into());
                self
            }
            pub fn max_comment_length(mut self, max_comment_length: i32) -> Self {
                self.max_comment_length = Some(max_comment_length);
                self
            }
            pub fn skip(mut self, skip: i32) -> Self {
                self.skip = Some(skip);
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/pullrequests",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(search_criteria_creator_id) = &this.search_criteria_creator_id {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.creatorId",
                                search_criteria_creator_id,
                            );
                        }
                        if let Some(search_criteria_include_links) =
                            &this.search_criteria_include_links
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.includeLinks",
                                &search_criteria_include_links.to_string(),
                            );
                        }
                        if let Some(search_criteria_repository_id) =
                            &this.search_criteria_repository_id
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.repositoryId",
                                search_criteria_repository_id,
                            );
                        }
                        if let Some(search_criteria_reviewer_id) = &this.search_criteria_reviewer_id
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.reviewerId",
                                search_criteria_reviewer_id,
                            );
                        }
                        if let Some(search_criteria_source_ref_name) =
                            &this.search_criteria_source_ref_name
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.sourceRefName",
                                search_criteria_source_ref_name,
                            );
                        }
                        if let Some(search_criteria_source_repository_id) =
                            &this.search_criteria_source_repository_id
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.sourceRepositoryId",
                                search_criteria_source_repository_id,
                            );
                        }
                        if let Some(search_criteria_status) = &this.search_criteria_status {
                            url.query_pairs_mut()
                                .append_pair("searchCriteria.status", search_criteria_status);
                        }
                        if let Some(search_criteria_target_ref_name) =
                            &this.search_criteria_target_ref_name
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.targetRefName",
                                search_criteria_target_ref_name,
                            );
                        }
                        if let Some(max_comment_length) = &this.max_comment_length {
                            url.query_pairs_mut()
                                .append_pair("maxCommentLength", &max_comment_length.to_string());
                        }
                        if let Some(skip) = &this.skip {
                            url.query_pairs_mut()
                                .append_pair("$skip", &skip.to_string());
                        }
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("$top", &top.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequestList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_pull_request_by_id {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequest;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/pullrequests/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequest =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_pull_requests {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequestList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) project: String,
            pub(crate) search_criteria_creator_id: Option<String>,
            pub(crate) search_criteria_include_links: Option<bool>,
            pub(crate) search_criteria_repository_id: Option<String>,
            pub(crate) search_criteria_reviewer_id: Option<String>,
            pub(crate) search_criteria_source_ref_name: Option<String>,
            pub(crate) search_criteria_source_repository_id: Option<String>,
            pub(crate) search_criteria_status: Option<String>,
            pub(crate) search_criteria_target_ref_name: Option<String>,
            pub(crate) max_comment_length: Option<i32>,
            pub(crate) skip: Option<i32>,
            pub(crate) top: Option<i32>,
        }
        impl Builder {
            pub fn search_criteria_creator_id(
                mut self,
                search_criteria_creator_id: impl Into<String>,
            ) -> Self {
                self.search_criteria_creator_id = Some(search_criteria_creator_id.into());
                self
            }
            pub fn search_criteria_include_links(
                mut self,
                search_criteria_include_links: bool,
            ) -> Self {
                self.search_criteria_include_links = Some(search_criteria_include_links);
                self
            }
            pub fn search_criteria_repository_id(
                mut self,
                search_criteria_repository_id: impl Into<String>,
            ) -> Self {
                self.search_criteria_repository_id = Some(search_criteria_repository_id.into());
                self
            }
            pub fn search_criteria_reviewer_id(
                mut self,
                search_criteria_reviewer_id: impl Into<String>,
            ) -> Self {
                self.search_criteria_reviewer_id = Some(search_criteria_reviewer_id.into());
                self
            }
            pub fn search_criteria_source_ref_name(
                mut self,
                search_criteria_source_ref_name: impl Into<String>,
            ) -> Self {
                self.search_criteria_source_ref_name = Some(search_criteria_source_ref_name.into());
                self
            }
            pub fn search_criteria_source_repository_id(
                mut self,
                search_criteria_source_repository_id: impl Into<String>,
            ) -> Self {
                self.search_criteria_source_repository_id =
                    Some(search_criteria_source_repository_id.into());
                self
            }
            pub fn search_criteria_status(
                mut self,
                search_criteria_status: impl Into<String>,
            ) -> Self {
                self.search_criteria_status = Some(search_criteria_status.into());
                self
            }
            pub fn search_criteria_target_ref_name(
                mut self,
                search_criteria_target_ref_name: impl Into<String>,
            ) -> Self {
                self.search_criteria_target_ref_name = Some(search_criteria_target_ref_name.into());
                self
            }
            pub fn max_comment_length(mut self, max_comment_length: i32) -> Self {
                self.max_comment_length = Some(max_comment_length);
                self
            }
            pub fn skip(mut self, skip: i32) -> Self {
                self.skip = Some(skip);
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullrequests",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(search_criteria_creator_id) = &this.search_criteria_creator_id {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.creatorId",
                                search_criteria_creator_id,
                            );
                        }
                        if let Some(search_criteria_include_links) =
                            &this.search_criteria_include_links
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.includeLinks",
                                &search_criteria_include_links.to_string(),
                            );
                        }
                        if let Some(search_criteria_repository_id) =
                            &this.search_criteria_repository_id
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.repositoryId",
                                search_criteria_repository_id,
                            );
                        }
                        if let Some(search_criteria_reviewer_id) = &this.search_criteria_reviewer_id
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.reviewerId",
                                search_criteria_reviewer_id,
                            );
                        }
                        if let Some(search_criteria_source_ref_name) =
                            &this.search_criteria_source_ref_name
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.sourceRefName",
                                search_criteria_source_ref_name,
                            );
                        }
                        if let Some(search_criteria_source_repository_id) =
                            &this.search_criteria_source_repository_id
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.sourceRepositoryId",
                                search_criteria_source_repository_id,
                            );
                        }
                        if let Some(search_criteria_status) = &this.search_criteria_status {
                            url.query_pairs_mut()
                                .append_pair("searchCriteria.status", search_criteria_status);
                        }
                        if let Some(search_criteria_target_ref_name) =
                            &this.search_criteria_target_ref_name
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.targetRefName",
                                search_criteria_target_ref_name,
                            );
                        }
                        if let Some(max_comment_length) = &this.max_comment_length {
                            url.query_pairs_mut()
                                .append_pair("maxCommentLength", &max_comment_length.to_string());
                        }
                        if let Some(skip) = &this.skip {
                            url.query_pairs_mut()
                                .append_pair("$skip", &skip.to_string());
                        }
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("$top", &top.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequestList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequest;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitPullRequest,
            pub(crate) repository_id: String,
            pub(crate) project: String,
            pub(crate) supports_iterations: Option<bool>,
        }
        impl Builder {
            pub fn supports_iterations(mut self, supports_iterations: bool) -> Self {
                self.supports_iterations = Some(supports_iterations);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullrequests",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        if let Some(supports_iterations) = &this.supports_iterations {
                            url.query_pairs_mut().append_pair(
                                "supportsIterations",
                                &supports_iterations.to_string(),
                            );
                        }
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequest =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_pull_request {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequest;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
            pub(crate) max_comment_length: Option<i32>,
            pub(crate) skip: Option<i32>,
            pub(crate) top: Option<i32>,
            pub(crate) include_commits: Option<bool>,
            pub(crate) include_work_item_refs: Option<bool>,
        }
        impl Builder {
            pub fn max_comment_length(mut self, max_comment_length: i32) -> Self {
                self.max_comment_length = Some(max_comment_length);
                self
            }
            pub fn skip(mut self, skip: i32) -> Self {
                self.skip = Some(skip);
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn include_commits(mut self, include_commits: bool) -> Self {
                self.include_commits = Some(include_commits);
                self
            }
            pub fn include_work_item_refs(mut self, include_work_item_refs: bool) -> Self {
                self.include_work_item_refs = Some(include_work_item_refs);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullrequests/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(max_comment_length) = &this.max_comment_length {
                            url.query_pairs_mut()
                                .append_pair("maxCommentLength", &max_comment_length.to_string());
                        }
                        if let Some(skip) = &this.skip {
                            url.query_pairs_mut()
                                .append_pair("$skip", &skip.to_string());
                        }
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("$top", &top.to_string());
                        }
                        if let Some(include_commits) = &this.include_commits {
                            url.query_pairs_mut()
                                .append_pair("includeCommits", &include_commits.to_string());
                        }
                        if let Some(include_work_item_refs) = &this.include_work_item_refs {
                            url.query_pairs_mut().append_pair(
                                "includeWorkItemRefs",
                                &include_work_item_refs.to_string(),
                            );
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequest =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequest;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitPullRequest,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullrequests/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequest =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod annotated_tags {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitAnnotatedTag>,
            project: impl Into<String>,
            repository_id: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                repository_id: repository_id.into(),
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            repository_id: impl Into<String>,
            object_id: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                repository_id: repository_id.into(),
                object_id: object_id.into(),
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitAnnotatedTag;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitAnnotatedTag,
            pub(crate) project: String,
            pub(crate) repository_id: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/annotatedtags",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitAnnotatedTag =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitAnnotatedTag;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) repository_id: String,
            pub(crate) object_id: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/annotatedtags/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.object_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitAnnotatedTag =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod blobs {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_blobs_zip(
            &self,
            organization: impl Into<String>,
            body: Vec<String>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_blobs_zip::Builder {
            get_blobs_zip::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body,
                repository_id: repository_id.into(),
                project: project.into(),
                filename: None,
            }
        }
        pub fn get_blob(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            sha1: impl Into<String>,
            project: impl Into<String>,
        ) -> get_blob::Builder {
            get_blob::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                sha1: sha1.into(),
                project: project.into(),
                download: None,
                file_name: None,
                format: None,
                resolve_lfs: None,
            }
        }
    }
    pub mod get_blobs_zip {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = String;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: Vec<String>,
            pub(crate) repository_id: String,
            pub(crate) project: String,
            pub(crate) filename: Option<String>,
        }
        impl Builder {
            pub fn filename(mut self, filename: impl Into<String>) -> Self {
                self.filename = Some(filename.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/blobs",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        if let Some(filename) = &this.filename {
                            url.query_pairs_mut().append_pair("filename", filename);
                        }
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: String = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_blob {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitBlobRef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) sha1: String,
            pub(crate) project: String,
            pub(crate) download: Option<bool>,
            pub(crate) file_name: Option<String>,
            pub(crate) format: Option<String>,
            pub(crate) resolve_lfs: Option<bool>,
        }
        impl Builder {
            pub fn download(mut self, download: bool) -> Self {
                self.download = Some(download);
                self
            }
            pub fn file_name(mut self, file_name: impl Into<String>) -> Self {
                self.file_name = Some(file_name.into());
                self
            }
            pub fn format(mut self, format: impl Into<String>) -> Self {
                self.format = Some(format.into());
                self
            }
            pub fn resolve_lfs(mut self, resolve_lfs: bool) -> Self {
                self.resolve_lfs = Some(resolve_lfs);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/blobs/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.sha1
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(download) = &this.download {
                            url.query_pairs_mut()
                                .append_pair("download", &download.to_string());
                        }
                        if let Some(file_name) = &this.file_name {
                            url.query_pairs_mut().append_pair("fileName", file_name);
                        }
                        if let Some(format) = &this.format {
                            url.query_pairs_mut().append_pair("$format", format);
                        }
                        if let Some(resolve_lfs) = &this.resolve_lfs {
                            url.query_pairs_mut()
                                .append_pair("resolveLfs", &resolve_lfs.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitBlobRef =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod cherry_picks {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_cherry_pick_for_ref_name(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            repository_id: impl Into<String>,
            ref_name: impl Into<String>,
        ) -> get_cherry_pick_for_ref_name::Builder {
            get_cherry_pick_for_ref_name::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                repository_id: repository_id.into(),
                ref_name: ref_name.into(),
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitAsyncRefOperationParameters>,
            project: impl Into<String>,
            repository_id: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                repository_id: repository_id.into(),
            }
        }
        pub fn get_cherry_pick(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            cherry_pick_id: i32,
            repository_id: impl Into<String>,
        ) -> get_cherry_pick::Builder {
            get_cherry_pick::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                cherry_pick_id,
                repository_id: repository_id.into(),
            }
        }
    }
    pub mod get_cherry_pick_for_ref_name {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitCherryPick;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) repository_id: String,
            pub(crate) ref_name: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/cherryPicks",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let ref_name = &this.ref_name;
                        url.query_pairs_mut().append_pair("refName", ref_name);
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitCherryPick =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitCherryPick;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitAsyncRefOperationParameters,
            pub(crate) project: String,
            pub(crate) repository_id: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/cherryPicks",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitCherryPick =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_cherry_pick {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitCherryPick;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) cherry_pick_id: i32,
            pub(crate) repository_id: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/cherryPicks/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.cherry_pick_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitCherryPick =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod statuses {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            commit_id: impl Into<String>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                commit_id: commit_id.into(),
                repository_id: repository_id.into(),
                project: project.into(),
                top: None,
                skip: None,
                latest_only: None,
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitStatus>,
            commit_id: impl Into<String>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                commit_id: commit_id.into(),
                repository_id: repository_id.into(),
                project: project.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitStatusList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) commit_id: String,
            pub(crate) repository_id: String,
            pub(crate) project: String,
            pub(crate) top: Option<i32>,
            pub(crate) skip: Option<i32>,
            pub(crate) latest_only: Option<bool>,
        }
        impl Builder {
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn skip(mut self, skip: i32) -> Self {
                self.skip = Some(skip);
                self
            }
            pub fn latest_only(mut self, latest_only: bool) -> Self {
                self.latest_only = Some(latest_only);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/commits/{}/statuses",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.commit_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("top", &top.to_string());
                        }
                        if let Some(skip) = &this.skip {
                            url.query_pairs_mut().append_pair("skip", &skip.to_string());
                        }
                        if let Some(latest_only) = &this.latest_only {
                            url.query_pairs_mut()
                                .append_pair("latestOnly", &latest_only.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitStatusList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitStatus;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitStatus,
            pub(crate) commit_id: String,
            pub(crate) repository_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/commits/{}/statuses",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.commit_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitStatus =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod diffs {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                project: project.into(),
                diff_common_commit: None,
                top: None,
                skip: None,
                base_version: None,
                base_version_options: None,
                base_version_type: None,
                target_version: None,
                target_version_options: None,
                target_version_type: None,
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitCommitDiffs;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) project: String,
            pub(crate) diff_common_commit: Option<bool>,
            pub(crate) top: Option<i32>,
            pub(crate) skip: Option<i32>,
            pub(crate) base_version: Option<String>,
            pub(crate) base_version_options: Option<String>,
            pub(crate) base_version_type: Option<String>,
            pub(crate) target_version: Option<String>,
            pub(crate) target_version_options: Option<String>,
            pub(crate) target_version_type: Option<String>,
        }
        impl Builder {
            pub fn diff_common_commit(mut self, diff_common_commit: bool) -> Self {
                self.diff_common_commit = Some(diff_common_commit);
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn skip(mut self, skip: i32) -> Self {
                self.skip = Some(skip);
                self
            }
            pub fn base_version(mut self, base_version: impl Into<String>) -> Self {
                self.base_version = Some(base_version.into());
                self
            }
            pub fn base_version_options(mut self, base_version_options: impl Into<String>) -> Self {
                self.base_version_options = Some(base_version_options.into());
                self
            }
            pub fn base_version_type(mut self, base_version_type: impl Into<String>) -> Self {
                self.base_version_type = Some(base_version_type.into());
                self
            }
            pub fn target_version(mut self, target_version: impl Into<String>) -> Self {
                self.target_version = Some(target_version.into());
                self
            }
            pub fn target_version_options(
                mut self,
                target_version_options: impl Into<String>,
            ) -> Self {
                self.target_version_options = Some(target_version_options.into());
                self
            }
            pub fn target_version_type(mut self, target_version_type: impl Into<String>) -> Self {
                self.target_version_type = Some(target_version_type.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/diffs/commits",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(diff_common_commit) = &this.diff_common_commit {
                            url.query_pairs_mut()
                                .append_pair("diffCommonCommit", &diff_common_commit.to_string());
                        }
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("$top", &top.to_string());
                        }
                        if let Some(skip) = &this.skip {
                            url.query_pairs_mut()
                                .append_pair("$skip", &skip.to_string());
                        }
                        if let Some(base_version) = &this.base_version {
                            url.query_pairs_mut()
                                .append_pair("baseVersion", base_version);
                        }
                        if let Some(base_version_options) = &this.base_version_options {
                            url.query_pairs_mut()
                                .append_pair("baseVersionOptions", base_version_options);
                        }
                        if let Some(base_version_type) = &this.base_version_type {
                            url.query_pairs_mut()
                                .append_pair("baseVersionType", base_version_type);
                        }
                        if let Some(target_version) = &this.target_version {
                            url.query_pairs_mut()
                                .append_pair("targetVersion", target_version);
                        }
                        if let Some(target_version_options) = &this.target_version_options {
                            url.query_pairs_mut()
                                .append_pair("targetVersionOptions", target_version_options);
                        }
                        if let Some(target_version_type) = &this.target_version_type {
                            url.query_pairs_mut()
                                .append_pair("targetVersionType", target_version_type);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitCommitDiffs =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod import_requests {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn query(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            repository_id: impl Into<String>,
        ) -> query::Builder {
            query::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                repository_id: repository_id.into(),
                include_abandoned: None,
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitImportRequest>,
            project: impl Into<String>,
            repository_id: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                repository_id: repository_id.into(),
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            repository_id: impl Into<String>,
            import_request_id: i32,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                repository_id: repository_id.into(),
                import_request_id,
            }
        }
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitImportRequest>,
            project: impl Into<String>,
            repository_id: impl Into<String>,
            import_request_id: i32,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                repository_id: repository_id.into(),
                import_request_id,
            }
        }
    }
    pub mod query {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitImportRequestList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) repository_id: String,
            pub(crate) include_abandoned: Option<bool>,
        }
        impl Builder {
            pub fn include_abandoned(mut self, include_abandoned: bool) -> Self {
                self.include_abandoned = Some(include_abandoned);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/importRequests",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(include_abandoned) = &this.include_abandoned {
                            url.query_pairs_mut()
                                .append_pair("includeAbandoned", &include_abandoned.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitImportRequestList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitImportRequest;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitImportRequest,
            pub(crate) project: String,
            pub(crate) repository_id: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/importRequests",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitImportRequest =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitImportRequest;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) repository_id: String,
            pub(crate) import_request_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/importRequests/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.import_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitImportRequest =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitImportRequest;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitImportRequest,
            pub(crate) project: String,
            pub(crate) repository_id: String,
            pub(crate) import_request_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/importRequests/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.import_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitImportRequest =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod pull_request_query {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitPullRequestQuery>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                project: project.into(),
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequestQuery;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitPullRequestQuery,
            pub(crate) repository_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullrequestquery",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequestQuery =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod pull_request_attachments {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            file_name: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                file_name: file_name.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<String>,
            file_name: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                file_name: file_name.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
            }
        }
        pub fn delete(
            &self,
            organization: impl Into<String>,
            file_name: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                file_name: file_name.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::AttachmentList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/attachments",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AttachmentList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = String;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) file_name: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/attachments/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id,
                            &this.file_name
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: String = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        #[derive(Debug)]
        pub enum Response {
            Created201(models::Attachment),
            Accepted202(models::Attachment),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: String,
            pub(crate) file_name: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/attachments/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id,
                            &this.file_name
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::CREATED => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::Attachment =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(Response::Created201(rsp_value))
                            }
                            http::StatusCode::ACCEPTED => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::Attachment =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(Response::Accepted202(rsp_value))
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) file_name: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/attachments/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id,
                            &this.file_name
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::DELETE);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod pull_request_commits {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_pull_request_commits(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> get_pull_request_commits::Builder {
            get_pull_request_commits::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
                top: None,
                continuation_token: None,
            }
        }
        pub fn get_pull_request_iteration_commits(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            iteration_id: i32,
            project: impl Into<String>,
        ) -> get_pull_request_iteration_commits::Builder {
            get_pull_request_iteration_commits::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                iteration_id,
                project: project.into(),
                top: None,
                skip: None,
            }
        }
    }
    pub mod get_pull_request_commits {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitCommitRefList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
            pub(crate) top: Option<i32>,
            pub(crate) continuation_token: Option<String>,
        }
        impl Builder {
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
                self.continuation_token = Some(continuation_token.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/commits",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("$top", &top.to_string());
                        }
                        if let Some(continuation_token) = &this.continuation_token {
                            url.query_pairs_mut()
                                .append_pair("continuationToken", continuation_token);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitCommitRefList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_pull_request_iteration_commits {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitCommitRefList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) iteration_id: i32,
            pub(crate) project: String,
            pub(crate) top: Option<i32>,
            pub(crate) skip: Option<i32>,
        }
        impl Builder {
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn skip(mut self, skip: i32) -> Self {
                self.skip = Some(skip);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/iterations/{}/commits" , this . client . endpoint () , & this . organization , & this . project , & this . repository_id , & this . pull_request_id , & this . iteration_id) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("top", &top.to_string());
                        }
                        if let Some(skip) = &this.skip {
                            url.query_pairs_mut().append_pair("skip", &skip.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitCommitRefList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod pull_request_iterations {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
                include_commits: None,
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            iteration_id: i32,
            project: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                iteration_id,
                project: project.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequestIterationList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
            pub(crate) include_commits: Option<bool>,
        }
        impl Builder {
            pub fn include_commits(mut self, include_commits: bool) -> Self {
                self.include_commits = Some(include_commits);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/iterations",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(include_commits) = &this.include_commits {
                            url.query_pairs_mut()
                                .append_pair("includeCommits", &include_commits.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequestIterationList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequestIteration;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) iteration_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/iterations/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id,
                            &this.iteration_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequestIteration =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod pull_request_iteration_changes {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            iteration_id: i32,
            project: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                iteration_id,
                project: project.into(),
                top: None,
                skip: None,
                compare_to: None,
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequestIterationChanges;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) iteration_id: i32,
            pub(crate) project: String,
            pub(crate) top: Option<i32>,
            pub(crate) skip: Option<i32>,
            pub(crate) compare_to: Option<i32>,
        }
        impl Builder {
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn skip(mut self, skip: i32) -> Self {
                self.skip = Some(skip);
                self
            }
            pub fn compare_to(mut self, compare_to: i32) -> Self {
                self.compare_to = Some(compare_to);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/iterations/{}/changes" , this . client . endpoint () , & this . organization , & this . project , & this . repository_id , & this . pull_request_id , & this . iteration_id) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("$top", &top.to_string());
                        }
                        if let Some(skip) = &this.skip {
                            url.query_pairs_mut()
                                .append_pair("$skip", &skip.to_string());
                        }
                        if let Some(compare_to) = &this.compare_to {
                            url.query_pairs_mut()
                                .append_pair("$compareTo", &compare_to.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequestIterationChanges =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod pull_request_iteration_statuses {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            iteration_id: i32,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                iteration_id,
                project: project.into(),
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitPullRequestStatus>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            iteration_id: i32,
            project: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                iteration_id,
                project: project.into(),
            }
        }
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::JsonPatchDocument>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            iteration_id: i32,
            project: impl Into<String>,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                iteration_id,
                project: project.into(),
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            iteration_id: i32,
            status_id: i32,
            project: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                iteration_id,
                status_id,
                project: project.into(),
            }
        }
        pub fn delete(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            iteration_id: i32,
            status_id: i32,
            project: impl Into<String>,
        ) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                iteration_id,
                status_id,
                project: project.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequestStatusList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) iteration_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/iterations/{}/statuses" , this . client . endpoint () , & this . organization , & this . project , & this . repository_id , & this . pull_request_id , & this . iteration_id) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequestStatusList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequestStatus;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitPullRequestStatus,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) iteration_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/iterations/{}/statuses" , this . client . endpoint () , & this . organization , & this . project , & this . repository_id , & this . pull_request_id , & this . iteration_id) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequestStatus =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::JsonPatchDocument,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) iteration_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/iterations/{}/statuses" , this . client . endpoint () , & this . organization , & this . project , & this . repository_id , & this . pull_request_id , & this . iteration_id) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequestStatus;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) iteration_id: i32,
            pub(crate) status_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/iterations/{}/statuses/{}" , this . client . endpoint () , & this . organization , & this . project , & this . repository_id , & this . pull_request_id , & this . iteration_id , & this . status_id) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequestStatus =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) iteration_id: i32,
            pub(crate) status_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/iterations/{}/statuses/{}" , this . client . endpoint () , & this . organization , & this . project , & this . repository_id , & this . pull_request_id , & this . iteration_id , & this . status_id) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::DELETE);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod pull_request_labels {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
                project_id: None,
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::WebApiCreateTagRequestData>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
                project_id: None,
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            label_id_or_name: impl Into<String>,
            project: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                label_id_or_name: label_id_or_name.into(),
                project: project.into(),
                project_id: None,
            }
        }
        pub fn delete(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            label_id_or_name: impl Into<String>,
            project: impl Into<String>,
        ) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                label_id_or_name: label_id_or_name.into(),
                project: project.into(),
                project_id: None,
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::WebApiTagDefinitionList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
            pub(crate) project_id: Option<String>,
        }
        impl Builder {
            pub fn project_id(mut self, project_id: impl Into<String>) -> Self {
                self.project_id = Some(project_id.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/labels",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(project_id) = &this.project_id {
                            url.query_pairs_mut().append_pair("projectId", project_id);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::WebApiTagDefinitionList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::WebApiTagDefinition;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::WebApiCreateTagRequestData,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
            pub(crate) project_id: Option<String>,
        }
        impl Builder {
            pub fn project_id(mut self, project_id: impl Into<String>) -> Self {
                self.project_id = Some(project_id.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/labels",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        if let Some(project_id) = &this.project_id {
                            url.query_pairs_mut().append_pair("projectId", project_id);
                        }
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::WebApiTagDefinition =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::WebApiTagDefinition;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) label_id_or_name: String,
            pub(crate) project: String,
            pub(crate) project_id: Option<String>,
        }
        impl Builder {
            pub fn project_id(mut self, project_id: impl Into<String>) -> Self {
                self.project_id = Some(project_id.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/labels/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id,
                            &this.label_id_or_name
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(project_id) = &this.project_id {
                            url.query_pairs_mut().append_pair("projectId", project_id);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::WebApiTagDefinition =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) label_id_or_name: String,
            pub(crate) project: String,
            pub(crate) project_id: Option<String>,
        }
        impl Builder {
            pub fn project_id(mut self, project_id: impl Into<String>) -> Self {
                self.project_id = Some(project_id.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/labels/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id,
                            &this.label_id_or_name
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::DELETE);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(project_id) = &this.project_id {
                            url.query_pairs_mut().append_pair("projectId", project_id);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod pull_request_properties {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
            }
        }
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::JsonPatchDocument>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::PropertiesCollection;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/properties",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::PropertiesCollection =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::PropertiesCollection;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::JsonPatchDocument,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/properties",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::PropertiesCollection =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod pull_request_reviewers {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
            }
        }
        pub fn create_pull_request_reviewers(
            &self,
            organization: impl Into<String>,
            body: Vec<models::IdentityRef>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> create_pull_request_reviewers::Builder {
            create_pull_request_reviewers::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body,
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
            }
        }
        pub fn create_unmaterialized_pull_request_reviewer(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::IdentityRefWithVote>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> create_unmaterialized_pull_request_reviewer::Builder {
            create_unmaterialized_pull_request_reviewer::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
            }
        }
        pub fn update_pull_request_reviewers(
            &self,
            organization: impl Into<String>,
            body: Vec<models::IdentityRefWithVote>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> update_pull_request_reviewers::Builder {
            update_pull_request_reviewers::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body,
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            reviewer_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                reviewer_id: reviewer_id.into(),
                project: project.into(),
            }
        }
        pub fn create_pull_request_reviewer(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::IdentityRefWithVote>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            reviewer_id: impl Into<String>,
            project: impl Into<String>,
        ) -> create_pull_request_reviewer::Builder {
            create_pull_request_reviewer::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                reviewer_id: reviewer_id.into(),
                project: project.into(),
            }
        }
        pub fn update_pull_request_reviewer(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::IdentityRefWithVote>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            reviewer_id: impl Into<String>,
            project: impl Into<String>,
        ) -> update_pull_request_reviewer::Builder {
            update_pull_request_reviewer::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                reviewer_id: reviewer_id.into(),
                project: project.into(),
            }
        }
        pub fn delete(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            reviewer_id: impl Into<String>,
            project: impl Into<String>,
        ) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                reviewer_id: reviewer_id.into(),
                project: project.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::IdentityRefWithVoteList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/reviewers",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::IdentityRefWithVoteList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create_pull_request_reviewers {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::IdentityRefWithVoteList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: Vec<models::IdentityRef>,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/reviewers",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::IdentityRefWithVoteList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create_unmaterialized_pull_request_reviewer {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::IdentityRefWithVote;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::IdentityRefWithVote,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/reviewers",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PUT);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::IdentityRefWithVote =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update_pull_request_reviewers {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: Vec<models::IdentityRefWithVote>,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/reviewers",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::IdentityRefWithVote;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) reviewer_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/reviewers/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id,
                            &this.reviewer_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::IdentityRefWithVote =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create_pull_request_reviewer {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::IdentityRefWithVote;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::IdentityRefWithVote,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) reviewer_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/reviewers/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id,
                            &this.reviewer_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PUT);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::IdentityRefWithVote =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update_pull_request_reviewer {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::IdentityRefWithVote;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::IdentityRefWithVote,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) reviewer_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/reviewers/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id,
                            &this.reviewer_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::IdentityRefWithVote =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) reviewer_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/reviewers/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id,
                            &this.reviewer_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::DELETE);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod pull_request_share {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn share_pull_request(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::ShareNotificationContext>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> share_pull_request::Builder {
            share_pull_request::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
            }
        }
    }
    pub mod share_pull_request {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::ShareNotificationContext,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/share",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod pull_request_statuses {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitPullRequestStatus>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
            }
        }
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::JsonPatchDocument>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            status_id: i32,
            project: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                status_id,
                project: project.into(),
            }
        }
        pub fn delete(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            status_id: i32,
            project: impl Into<String>,
        ) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                status_id,
                project: project.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequestStatusList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/statuses",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequestStatusList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequestStatus;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitPullRequestStatus,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/statuses",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequestStatus =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::JsonPatchDocument,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/statuses",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequestStatus;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) status_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/statuses/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id,
                            &this.status_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequestStatus =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) status_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/statuses/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id,
                            &this.status_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::DELETE);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod pull_request_threads {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
                iteration: None,
                base_iteration: None,
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitPullRequestCommentThread>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            thread_id: i32,
            project: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                thread_id,
                project: project.into(),
                iteration: None,
                base_iteration: None,
            }
        }
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitPullRequestCommentThread>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            thread_id: i32,
            project: impl Into<String>,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                thread_id,
                project: project.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequestCommentThreadList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
            pub(crate) iteration: Option<i32>,
            pub(crate) base_iteration: Option<i32>,
        }
        impl Builder {
            pub fn iteration(mut self, iteration: i32) -> Self {
                self.iteration = Some(iteration);
                self
            }
            pub fn base_iteration(mut self, base_iteration: i32) -> Self {
                self.base_iteration = Some(base_iteration);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/threads",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(iteration) = &this.iteration {
                            url.query_pairs_mut()
                                .append_pair("$iteration", &iteration.to_string());
                        }
                        if let Some(base_iteration) = &this.base_iteration {
                            url.query_pairs_mut()
                                .append_pair("$baseIteration", &base_iteration.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequestCommentThreadList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequestCommentThread;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitPullRequestCommentThread,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/threads",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequestCommentThread =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequestCommentThread;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) thread_id: i32,
            pub(crate) project: String,
            pub(crate) iteration: Option<i32>,
            pub(crate) base_iteration: Option<i32>,
        }
        impl Builder {
            pub fn iteration(mut self, iteration: i32) -> Self {
                self.iteration = Some(iteration);
                self
            }
            pub fn base_iteration(mut self, base_iteration: i32) -> Self {
                self.base_iteration = Some(base_iteration);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/threads/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id,
                            &this.thread_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(iteration) = &this.iteration {
                            url.query_pairs_mut()
                                .append_pair("$iteration", &iteration.to_string());
                        }
                        if let Some(base_iteration) = &this.base_iteration {
                            url.query_pairs_mut()
                                .append_pair("$baseIteration", &base_iteration.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequestCommentThread =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPullRequestCommentThread;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitPullRequestCommentThread,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) thread_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/threads/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id,
                            &this.thread_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPullRequestCommentThread =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod pull_request_thread_comments {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            thread_id: i32,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                thread_id,
                project: project.into(),
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::Comment>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            thread_id: i32,
            project: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                thread_id,
                project: project.into(),
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            thread_id: i32,
            comment_id: i32,
            project: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                thread_id,
                comment_id,
                project: project.into(),
            }
        }
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::Comment>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            thread_id: i32,
            comment_id: i32,
            project: impl Into<String>,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                thread_id,
                comment_id,
                project: project.into(),
            }
        }
        pub fn delete(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            thread_id: i32,
            comment_id: i32,
            project: impl Into<String>,
        ) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                thread_id,
                comment_id,
                project: project.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::CommentList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) thread_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/threads/{}/comments" , this . client . endpoint () , & this . organization , & this . project , & this . repository_id , & this . pull_request_id , & this . thread_id) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::CommentList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::Comment;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::Comment,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) thread_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/threads/{}/comments" , this . client . endpoint () , & this . organization , & this . project , & this . repository_id , & this . pull_request_id , & this . thread_id) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::Comment = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::Comment;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) thread_id: i32,
            pub(crate) comment_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/threads/{}/comments/{}" , this . client . endpoint () , & this . organization , & this . project , & this . repository_id , & this . pull_request_id , & this . thread_id , & this . comment_id) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::Comment = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::Comment;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::Comment,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) thread_id: i32,
            pub(crate) comment_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/threads/{}/comments/{}" , this . client . endpoint () , & this . organization , & this . project , & this . repository_id , & this . pull_request_id , & this . thread_id , & this . comment_id) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::Comment = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) thread_id: i32,
            pub(crate) comment_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/threads/{}/comments/{}" , this . client . endpoint () , & this . organization , & this . project , & this . repository_id , & this . pull_request_id , & this . thread_id , & this . comment_id) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::DELETE);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod pull_request_comment_likes {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            thread_id: i32,
            comment_id: i32,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                thread_id,
                comment_id,
                project: project.into(),
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            thread_id: i32,
            comment_id: i32,
            project: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                thread_id,
                comment_id,
                project: project.into(),
            }
        }
        pub fn delete(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            thread_id: i32,
            comment_id: i32,
            project: impl Into<String>,
        ) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                thread_id,
                comment_id,
                project: project.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::IdentityRefList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) thread_id: i32,
            pub(crate) comment_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/threads/{}/comments/{}/likes" , this . client . endpoint () , & this . organization , & this . project , & this . repository_id , & this . pull_request_id , & this . thread_id , & this . comment_id) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::IdentityRefList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) thread_id: i32,
            pub(crate) comment_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/threads/{}/comments/{}/likes" , this . client . endpoint () , & this . organization , & this . project , & this . repository_id , & this . pull_request_id , & this . thread_id , & this . comment_id) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) thread_id: i32,
            pub(crate) comment_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/threads/{}/comments/{}/likes" , this . client . endpoint () , & this . organization , & this . project , & this . repository_id , & this . pull_request_id , & this . thread_id , & this . comment_id) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::DELETE);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod pull_request_work_items {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            pull_request_id: i32,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                pull_request_id,
                project: project.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::ResourceRefList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) pull_request_id: i32,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pullRequests/{}/workitems",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.pull_request_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ResourceRefList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod pushes {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                project: project.into(),
                skip: None,
                top: None,
                search_criteria_from_date: None,
                search_criteria_include_links: None,
                search_criteria_include_ref_updates: None,
                search_criteria_pusher_id: None,
                search_criteria_ref_name: None,
                search_criteria_to_date: None,
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitPush>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                project: project.into(),
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            push_id: i32,
            project: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                push_id,
                project: project.into(),
                include_commits: None,
                include_ref_updates: None,
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPushList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) project: String,
            pub(crate) skip: Option<i32>,
            pub(crate) top: Option<i32>,
            pub(crate) search_criteria_from_date: Option<String>,
            pub(crate) search_criteria_include_links: Option<bool>,
            pub(crate) search_criteria_include_ref_updates: Option<bool>,
            pub(crate) search_criteria_pusher_id: Option<String>,
            pub(crate) search_criteria_ref_name: Option<String>,
            pub(crate) search_criteria_to_date: Option<String>,
        }
        impl Builder {
            pub fn skip(mut self, skip: i32) -> Self {
                self.skip = Some(skip);
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn search_criteria_from_date(
                mut self,
                search_criteria_from_date: impl Into<String>,
            ) -> Self {
                self.search_criteria_from_date = Some(search_criteria_from_date.into());
                self
            }
            pub fn search_criteria_include_links(
                mut self,
                search_criteria_include_links: bool,
            ) -> Self {
                self.search_criteria_include_links = Some(search_criteria_include_links);
                self
            }
            pub fn search_criteria_include_ref_updates(
                mut self,
                search_criteria_include_ref_updates: bool,
            ) -> Self {
                self.search_criteria_include_ref_updates =
                    Some(search_criteria_include_ref_updates);
                self
            }
            pub fn search_criteria_pusher_id(
                mut self,
                search_criteria_pusher_id: impl Into<String>,
            ) -> Self {
                self.search_criteria_pusher_id = Some(search_criteria_pusher_id.into());
                self
            }
            pub fn search_criteria_ref_name(
                mut self,
                search_criteria_ref_name: impl Into<String>,
            ) -> Self {
                self.search_criteria_ref_name = Some(search_criteria_ref_name.into());
                self
            }
            pub fn search_criteria_to_date(
                mut self,
                search_criteria_to_date: impl Into<String>,
            ) -> Self {
                self.search_criteria_to_date = Some(search_criteria_to_date.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pushes",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(skip) = &this.skip {
                            url.query_pairs_mut()
                                .append_pair("$skip", &skip.to_string());
                        }
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("$top", &top.to_string());
                        }
                        if let Some(search_criteria_from_date) = &this.search_criteria_from_date {
                            url.query_pairs_mut()
                                .append_pair("searchCriteria.fromDate", search_criteria_from_date);
                        }
                        if let Some(search_criteria_include_links) =
                            &this.search_criteria_include_links
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.includeLinks",
                                &search_criteria_include_links.to_string(),
                            );
                        }
                        if let Some(search_criteria_include_ref_updates) =
                            &this.search_criteria_include_ref_updates
                        {
                            url.query_pairs_mut().append_pair(
                                "searchCriteria.includeRefUpdates",
                                &search_criteria_include_ref_updates.to_string(),
                            );
                        }
                        if let Some(search_criteria_pusher_id) = &this.search_criteria_pusher_id {
                            url.query_pairs_mut()
                                .append_pair("searchCriteria.pusherId", search_criteria_pusher_id);
                        }
                        if let Some(search_criteria_ref_name) = &this.search_criteria_ref_name {
                            url.query_pairs_mut()
                                .append_pair("searchCriteria.refName", search_criteria_ref_name);
                        }
                        if let Some(search_criteria_to_date) = &this.search_criteria_to_date {
                            url.query_pairs_mut()
                                .append_pair("searchCriteria.toDate", search_criteria_to_date);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPushList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPush;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitPush,
            pub(crate) repository_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pushes",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPush = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitPush;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) push_id: i32,
            pub(crate) project: String,
            pub(crate) include_commits: Option<i32>,
            pub(crate) include_ref_updates: Option<bool>,
        }
        impl Builder {
            pub fn include_commits(mut self, include_commits: i32) -> Self {
                self.include_commits = Some(include_commits);
                self
            }
            pub fn include_ref_updates(mut self, include_ref_updates: bool) -> Self {
                self.include_ref_updates = Some(include_ref_updates);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/pushes/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.push_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(include_commits) = &this.include_commits {
                            url.query_pairs_mut()
                                .append_pair("includeCommits", &include_commits.to_string());
                        }
                        if let Some(include_ref_updates) = &this.include_ref_updates {
                            url.query_pairs_mut()
                                .append_pair("includeRefUpdates", &include_ref_updates.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitPush = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod refs {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                project: project.into(),
                filter: None,
                include_links: None,
                include_statuses: None,
                include_my_branches: None,
                latest_statuses_only: None,
                peel_tags: None,
                filter_contains: None,
                top: None,
                continuation_token: None,
            }
        }
        pub fn update_refs(
            &self,
            organization: impl Into<String>,
            body: Vec<models::GitRefUpdate>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> update_refs::Builder {
            update_refs::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body,
                repository_id: repository_id.into(),
                project: project.into(),
                project_id: None,
            }
        }
        pub fn update_ref(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitRefUpdate>,
            repository_id: impl Into<String>,
            filter: impl Into<String>,
            project: impl Into<String>,
        ) -> update_ref::Builder {
            update_ref::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_id: repository_id.into(),
                filter: filter.into(),
                project: project.into(),
                project_id: None,
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitRefList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) project: String,
            pub(crate) filter: Option<String>,
            pub(crate) include_links: Option<bool>,
            pub(crate) include_statuses: Option<bool>,
            pub(crate) include_my_branches: Option<bool>,
            pub(crate) latest_statuses_only: Option<bool>,
            pub(crate) peel_tags: Option<bool>,
            pub(crate) filter_contains: Option<String>,
            pub(crate) top: Option<i32>,
            pub(crate) continuation_token: Option<String>,
        }
        impl Builder {
            pub fn filter(mut self, filter: impl Into<String>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn include_links(mut self, include_links: bool) -> Self {
                self.include_links = Some(include_links);
                self
            }
            pub fn include_statuses(mut self, include_statuses: bool) -> Self {
                self.include_statuses = Some(include_statuses);
                self
            }
            pub fn include_my_branches(mut self, include_my_branches: bool) -> Self {
                self.include_my_branches = Some(include_my_branches);
                self
            }
            pub fn latest_statuses_only(mut self, latest_statuses_only: bool) -> Self {
                self.latest_statuses_only = Some(latest_statuses_only);
                self
            }
            pub fn peel_tags(mut self, peel_tags: bool) -> Self {
                self.peel_tags = Some(peel_tags);
                self
            }
            pub fn filter_contains(mut self, filter_contains: impl Into<String>) -> Self {
                self.filter_contains = Some(filter_contains.into());
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
                self.continuation_token = Some(continuation_token.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/refs",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(filter) = &this.filter {
                            url.query_pairs_mut().append_pair("filter", filter);
                        }
                        if let Some(include_links) = &this.include_links {
                            url.query_pairs_mut()
                                .append_pair("includeLinks", &include_links.to_string());
                        }
                        if let Some(include_statuses) = &this.include_statuses {
                            url.query_pairs_mut()
                                .append_pair("includeStatuses", &include_statuses.to_string());
                        }
                        if let Some(include_my_branches) = &this.include_my_branches {
                            url.query_pairs_mut()
                                .append_pair("includeMyBranches", &include_my_branches.to_string());
                        }
                        if let Some(latest_statuses_only) = &this.latest_statuses_only {
                            url.query_pairs_mut().append_pair(
                                "latestStatusesOnly",
                                &latest_statuses_only.to_string(),
                            );
                        }
                        if let Some(peel_tags) = &this.peel_tags {
                            url.query_pairs_mut()
                                .append_pair("peelTags", &peel_tags.to_string());
                        }
                        if let Some(filter_contains) = &this.filter_contains {
                            url.query_pairs_mut()
                                .append_pair("filterContains", filter_contains);
                        }
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("$top", &top.to_string());
                        }
                        if let Some(continuation_token) = &this.continuation_token {
                            url.query_pairs_mut()
                                .append_pair("continuationToken", continuation_token);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitRefList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update_refs {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitRefUpdateResultList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: Vec<models::GitRefUpdate>,
            pub(crate) repository_id: String,
            pub(crate) project: String,
            pub(crate) project_id: Option<String>,
        }
        impl Builder {
            pub fn project_id(mut self, project_id: impl Into<String>) -> Self {
                self.project_id = Some(project_id.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/refs",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        if let Some(project_id) = &this.project_id {
                            url.query_pairs_mut().append_pair("projectId", project_id);
                        }
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitRefUpdateResultList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update_ref {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitRef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitRefUpdate,
            pub(crate) repository_id: String,
            pub(crate) filter: String,
            pub(crate) project: String,
            pub(crate) project_id: Option<String>,
        }
        impl Builder {
            pub fn project_id(mut self, project_id: impl Into<String>) -> Self {
                self.project_id = Some(project_id.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/refs",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        let filter = &this.filter;
                        url.query_pairs_mut().append_pair("filter", filter);
                        if let Some(project_id) = &this.project_id {
                            url.query_pairs_mut().append_pair("projectId", project_id);
                        }
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitRef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod reverts {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_revert_for_ref_name(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            repository_id: impl Into<String>,
            ref_name: impl Into<String>,
        ) -> get_revert_for_ref_name::Builder {
            get_revert_for_ref_name::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                repository_id: repository_id.into(),
                ref_name: ref_name.into(),
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitAsyncRefOperationParameters>,
            project: impl Into<String>,
            repository_id: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                repository_id: repository_id.into(),
            }
        }
        pub fn get_revert(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            revert_id: i32,
            repository_id: impl Into<String>,
        ) -> get_revert::Builder {
            get_revert::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                revert_id,
                repository_id: repository_id.into(),
            }
        }
    }
    pub mod get_revert_for_ref_name {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitRevert;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) repository_id: String,
            pub(crate) ref_name: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/reverts",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let ref_name = &this.ref_name;
                        url.query_pairs_mut().append_pair("refName", ref_name);
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitRevert =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitRevert;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitAsyncRefOperationParameters,
            pub(crate) project: String,
            pub(crate) repository_id: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/reverts",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitRevert =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_revert {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitRevert;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) revert_id: i32,
            pub(crate) repository_id: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/reverts/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.revert_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitRevert =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod suggestions {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                project: project.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitSuggestionList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/suggestions",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitSuggestionList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod trees {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get(
            &self,
            organization: impl Into<String>,
            repository_id: impl Into<String>,
            sha1: impl Into<String>,
            project: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_id: repository_id.into(),
                sha1: sha1.into(),
                project: project.into(),
                project_id: None,
                recursive: None,
                file_name: None,
                format: None,
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitTreeRef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_id: String,
            pub(crate) sha1: String,
            pub(crate) project: String,
            pub(crate) project_id: Option<String>,
            pub(crate) recursive: Option<bool>,
            pub(crate) file_name: Option<String>,
            pub(crate) format: Option<String>,
        }
        impl Builder {
            pub fn project_id(mut self, project_id: impl Into<String>) -> Self {
                self.project_id = Some(project_id.into());
                self
            }
            pub fn recursive(mut self, recursive: bool) -> Self {
                self.recursive = Some(recursive);
                self
            }
            pub fn file_name(mut self, file_name: impl Into<String>) -> Self {
                self.file_name = Some(file_name.into());
                self
            }
            pub fn format(mut self, format: impl Into<String>) -> Self {
                self.format = Some(format.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/trees/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_id,
                            &this.sha1
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(project_id) = &this.project_id {
                            url.query_pairs_mut().append_pair("projectId", project_id);
                        }
                        if let Some(recursive) = &this.recursive {
                            url.query_pairs_mut()
                                .append_pair("recursive", &recursive.to_string());
                        }
                        if let Some(file_name) = &this.file_name {
                            url.query_pairs_mut().append_pair("fileName", file_name);
                        }
                        if let Some(format) = &this.format {
                            url.query_pairs_mut().append_pair("$format", format);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitTreeRef =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod merge_bases {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_name_or_id: impl Into<String>,
            commit_id: impl Into<String>,
            other_commit_id: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_name_or_id: repository_name_or_id.into(),
                commit_id: commit_id.into(),
                other_commit_id: other_commit_id.into(),
                project: project.into(),
                other_collection_id: None,
                other_repository_id: None,
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitCommitRefList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_name_or_id: String,
            pub(crate) commit_id: String,
            pub(crate) other_commit_id: String,
            pub(crate) project: String,
            pub(crate) other_collection_id: Option<String>,
            pub(crate) other_repository_id: Option<String>,
        }
        impl Builder {
            pub fn other_collection_id(mut self, other_collection_id: impl Into<String>) -> Self {
                self.other_collection_id = Some(other_collection_id.into());
                self
            }
            pub fn other_repository_id(mut self, other_repository_id: impl Into<String>) -> Self {
                self.other_repository_id = Some(other_repository_id.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/commits/{}/mergebases",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_name_or_id,
                            &this.commit_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let other_commit_id = &this.other_commit_id;
                        url.query_pairs_mut()
                            .append_pair("otherCommitId", other_commit_id);
                        if let Some(other_collection_id) = &this.other_collection_id {
                            url.query_pairs_mut()
                                .append_pair("otherCollectionId", other_collection_id);
                        }
                        if let Some(other_repository_id) = &this.other_repository_id {
                            url.query_pairs_mut()
                                .append_pair("otherRepositoryId", other_repository_id);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitCommitRefList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod forks {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            repository_name_or_id: impl Into<String>,
            collection_id: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_name_or_id: repository_name_or_id.into(),
                collection_id: collection_id.into(),
                project: project.into(),
                include_links: None,
            }
        }
        pub fn get_fork_sync_requests(
            &self,
            organization: impl Into<String>,
            repository_name_or_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_fork_sync_requests::Builder {
            get_fork_sync_requests::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_name_or_id: repository_name_or_id.into(),
                project: project.into(),
                include_abandoned: None,
                include_links: None,
            }
        }
        pub fn create_fork_sync_request(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitForkSyncRequestParameters>,
            repository_name_or_id: impl Into<String>,
            project: impl Into<String>,
        ) -> create_fork_sync_request::Builder {
            create_fork_sync_request::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                repository_name_or_id: repository_name_or_id.into(),
                project: project.into(),
                include_links: None,
            }
        }
        pub fn get_fork_sync_request(
            &self,
            organization: impl Into<String>,
            repository_name_or_id: impl Into<String>,
            fork_sync_operation_id: i32,
            project: impl Into<String>,
        ) -> get_fork_sync_request::Builder {
            get_fork_sync_request::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                repository_name_or_id: repository_name_or_id.into(),
                fork_sync_operation_id,
                project: project.into(),
                include_links: None,
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitRepositoryRefList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_name_or_id: String,
            pub(crate) collection_id: String,
            pub(crate) project: String,
            pub(crate) include_links: Option<bool>,
        }
        impl Builder {
            pub fn include_links(mut self, include_links: bool) -> Self {
                self.include_links = Some(include_links);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/forks/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_name_or_id,
                            &this.collection_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(include_links) = &this.include_links {
                            url.query_pairs_mut()
                                .append_pair("includeLinks", &include_links.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitRepositoryRefList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_fork_sync_requests {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitForkSyncRequestList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_name_or_id: String,
            pub(crate) project: String,
            pub(crate) include_abandoned: Option<bool>,
            pub(crate) include_links: Option<bool>,
        }
        impl Builder {
            pub fn include_abandoned(mut self, include_abandoned: bool) -> Self {
                self.include_abandoned = Some(include_abandoned);
                self
            }
            pub fn include_links(mut self, include_links: bool) -> Self {
                self.include_links = Some(include_links);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/forkSyncRequests",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_name_or_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(include_abandoned) = &this.include_abandoned {
                            url.query_pairs_mut()
                                .append_pair("includeAbandoned", &include_abandoned.to_string());
                        }
                        if let Some(include_links) = &this.include_links {
                            url.query_pairs_mut()
                                .append_pair("includeLinks", &include_links.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitForkSyncRequestList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create_fork_sync_request {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitForkSyncRequest;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitForkSyncRequestParameters,
            pub(crate) repository_name_or_id: String,
            pub(crate) project: String,
            pub(crate) include_links: Option<bool>,
        }
        impl Builder {
            pub fn include_links(mut self, include_links: bool) -> Self {
                self.include_links = Some(include_links);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/forkSyncRequests",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_name_or_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        if let Some(include_links) = &this.include_links {
                            url.query_pairs_mut()
                                .append_pair("includeLinks", &include_links.to_string());
                        }
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitForkSyncRequest =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_fork_sync_request {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitForkSyncRequest;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) repository_name_or_id: String,
            pub(crate) fork_sync_operation_id: i32,
            pub(crate) project: String,
            pub(crate) include_links: Option<bool>,
        }
        impl Builder {
            pub fn include_links(mut self, include_links: bool) -> Self {
                self.include_links = Some(include_links);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/forkSyncRequests/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_name_or_id,
                            &this.fork_sync_operation_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(include_links) = &this.include_links {
                            url.query_pairs_mut()
                                .append_pair("includeLinks", &include_links.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitForkSyncRequest =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod merges {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GitMergeParameters>,
            project: impl Into<String>,
            repository_name_or_id: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                repository_name_or_id: repository_name_or_id.into(),
                include_links: None,
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            repository_name_or_id: impl Into<String>,
            merge_operation_id: i32,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                repository_name_or_id: repository_name_or_id.into(),
                merge_operation_id,
                include_links: None,
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitMerge;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GitMergeParameters,
            pub(crate) project: String,
            pub(crate) repository_name_or_id: String,
            pub(crate) include_links: Option<bool>,
        }
        impl Builder {
            pub fn include_links(mut self, include_links: bool) -> Self {
                self.include_links = Some(include_links);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/merges",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_name_or_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        if let Some(include_links) = &this.include_links {
                            url.query_pairs_mut()
                                .append_pair("includeLinks", &include_links.to_string());
                        }
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitMerge =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::GitMerge;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) repository_name_or_id: String,
            pub(crate) merge_operation_id: i32,
            pub(crate) include_links: Option<bool>,
        }
        impl Builder {
            pub fn include_links(mut self, include_links: bool) -> Self {
                self.include_links = Some(include_links);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/git/repositories/{}/merges/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.repository_name_or_id,
                            &this.merge_operation_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(include_links) = &this.include_links {
                            url.query_pairs_mut()
                                .append_pair("includeLinks", &include_links.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::GitMerge =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
